<html><head>
<title>Python : Liste des projets</title>
<link rel="stylesheet" href="../CSS/base.css" type="text/css">
<head><body>

<h1>PYTHON : PROJETS 2022</h1>

L'objectif des projets proposés sur cette page, est de combiner le paradigme de 
<b>programmation objet</b> avec la réalisation d'un programme mettant en oeuvre 
la <b>séparation noyau/interface</b>. Pour chacun des projets, il faudra donc 
mettre en place une organisation du code composée de deux ensembles de classes :

<ul>
<li>D'un côté, on va implémenter un ensemble de classes dont le rôle est de 
réaliser les fonctionnalités figurant dans le cahier des charges, 
indépendamment de toute interface utilisateur, en modélisant le problème à 
résoudre de manière purement formelle.</li>
<li>De l'autre côté, on va créer un second ensemble de classes qui utiliseront 
ce noyau pour proposer une interface utilisateur pour le programme. Selon le 
type de projet, on pourra même implémenter deux interfaces différentes, l'une 
en mode texte et l'autre en mode graphique.</li>
</ul>

<!---------------------------------------------------------------------------->
<h2>Projet 1 : Bridges</h2>

Ecrire un programme <span class="prog">bridges</span> qui implémente le jeu de 
connexions, originaire du Japon, sous le nom de <b>Hashiwokakero</b> (cf.
cette <a href="https://fr.wikipedia.org/wiki/Hashiwokakero"><b>page 
Wikipedia</b></a> pour avoir toutes les informations sur les règles du jeu). 
L'objectif du joueur est de connecter l'ensemble des îles placées sur une 
grille, en construisant le nombre exact de ponts indiqué pour chaque île. Une 
version jouable en ligne se trouve sur <a 
href="http://www.brainbashers.com/bridges.asp"><b>ce site</b></a> et permet de 
se familiariser au mécanisme du jeu avec des exemples de complexité 
variable.<br><br>

Dans la version originale, chaque connexion d'une île avec l'une de ses 4 îles 
voisines (N, E, S, W) se visualise par un segment de droite qui symbolise un 
pont (connexion simple = un segment, connexion double = deux segments 
parallèles). Pour simplifier la fonction d'affichage, on ne visualisera les 
ponts que par un seul segment entre deux îles, mais dont l'épaisseur sera 
variable en fonction du nombre de voies de connexion (trait fin pour un pont 
simple voie, trait moyen pour un pont double voie, trait épais pour un pont 
triple voie). La valeur indiquée sur chaque île représente donc le nombre de 
voies de connexion avec les îles voisines (et non pas le nombre physique de 
ponts). Une des contraintes pour la création des niveaux est qu'il n'y a jamais 
plus de 9 voies de connexion pour une île donnée. La figure ci-dessous fournit 
un exemple possible pour l'interface graphique du programme, dans lequel on 
peut voir les 3 épaisseurs des ponts reliant les îles :<br><br>

<center><img src="../IMG/bridges.png" height="400"></center>

L'interaction entre le programe et le joueur s'effectue uniquement à l'aide
de la souris. Lorsque le joueur clique sur une première île, celle-ci devient
"active" (ce qui sera symbolisé par un changement de couleur du disque associé
à l'île), puis en cliquant sur une des îles voisines, un pont sera créé avec
un segment d'une épaisseur variable selon le nombre de clics. Si le joueur
réalise qu'il s'est trompé, il peut détruire un pont entre 2 îles en cliquant
avec le bouton droit au lieu du bouton gauche. Au fur et à mesure de la
création ou destruction des ponts, les compteurs sur les îles sont décrémentés
ou incrémentés. Par conséquent, lorsque tous les compteurs tombent à la valeur
0, le niveau est considéré comme résolu et le programme doit afficher le niveau
suivant.<br><br>

L'implémentation devra mettre en oeuvre au moins deux classes : une classe 
noyau chargée de modéliser le jeu de manière abstraite, et une classe interface 
chargée de créer la fenêtre graphique pour visualiser le plateau de jeu et de 
gérer les actions du joueur effectués à l'aide de la souris (mais évidemment, 
il est possible d'organiser l'architecture du code en un plus grand nombre de 
classes, si nécessaire). Pour simplifier le développement du programme, on 
fournit une archive ZIP <a href="PROJET/bridges.zip"><b>bridges.zip</b></a> qui 
contient un fichier CSV <b>bridges.csv</b> regroupant 1000 grilles de tailles 
variables, classées par niveau de difficulté, ainsi qu'un fichier démo 
<b>bridgesZ.py</b> qui pourra servir de point de départ pour l'implémentation. 
La décomposition en classes noyau/interface est déjà mise en oeuvre dans le 
fichier, mais il faudra évidemment compléter le code, en ajoutant des attributs 
et des méthodes dans chacune des classes.<br><br>

<b>Exemples à relire avant de commencer le projet :</b><br>
<ol>
<li> Exemple E7A_canvas.py (pour l'utilisation générale de la widget Canvas)
<li> Exemple E7D_canvas.py (pour la gestion des clics dans un Canvas)
<li> Exercice E8A_maze.py (pour la lecture des fichiers CSV)
<li> Exemples D6_peg.py (pour la séparation noyau/interface d'un programme)
</ol>

<!---------------------------------------------------------------------------->
<h2>Projet 2 : Card Crawl</h2>

Ecrire un programme <span class="prog">Crawl</span> qui implémente une variante 
du jeu <b>Card Crawl</b> disponible sur les smartphones Android et iOS, ainsi 
que sur Steam. Le jeu se place dans la famille des <a 
href="https://fr.wikipedia.org/wiki/Roguelike"><i><b>rogue-like 
games</b></i></a> dans lesquels le joueur joue le rôle d'un aventurier qui 
explore un donjon contenant monstres et trésors, et dont l'objectif est de 
sortir vivant du donjon en ayant tué tous les monstres rencontrés et en ayant 
accumulé un maximum de richesses.<br><br>

La différence avec les rogue-like habituels, est que le jeu se joue 
intégralement avec des cartes, réparties en 6 catégories : les monstres, les 
pièces d'or, les épées, les boucliers, les potions de guérison et les cartes 
magiques. Chaque "pièce" du donjon est représentée par un ensemble de 4 cartes 
qui sont distribués dans la zone de jeu (face au joueur) et que celui-ci devra 
soit récupérer (= les cartes d'or ou d'équipement) soit combattre (= les 
monstres). Le joueur ne possède que 3 emplacements pour stocker son équipement 
(main gauche, main droite et sac à dos) et il ne pourra passer à la pièce 
suivante tant qu'il reste plus d'une carte dans la zone de jeu. Des informations
complémentaires peuvent se trouver sur <a href="http://www.cardcrawl.com"><b>le
site officiel du jeu</b></a> mais comme pour le sujet précédent, le plus simple
pour comprendre le principe du jeu, est de passer par une <a href="https://www.youtube.com/watch?v=bJpWtrCwL94"><b>vidéo 
détaillant les règles et le gameplay</b></a>.<br><br>

<center><img src="../IMG/crawl.png" width="900"></center><br>

La figure ci-dessous montre une copie d'écran de l'interface à réaliser dans le 
cadre de ce projet. L'image de gauche montre la configuration initiale avant de 
démarrer la partie, et l'image de droite montre la configuration au cours d'une 
partie. La case en haut à gauche indique à tout moment le nombre de cartes 
restantes avant la fin du niveau en cours (dans le jeu originel, chaque niveau 
comporte 54 cartes, mais rien ne vous empêche de mettre en place un nombre 
variable de cartes par niveau), les 4 autres case du haut correspondent aux 
cartes distribuées pour la "pièce" du donjon en cours d'exploration. La case en 
bas à gauche est la case de recyclage : à tout moment, le joueur peut choisir 
de sacrifier une carte (hors monstre) sur cette case, afin de redistribuer un 
nombre variable de cartes dans la zone du haut (si la carte sacrifiée a une 
valeur de 1, 2 ou 3, le programme échange 1 carte au hasard de la zone de jeu 
avec les cartes restantes, si la valeur est 4, 5 ou 6, on échange 2 cartes, et 
si la valeur est 7, 8 ou 9, on échange 3 cartes au hasard). Les 4 autres cases 
de la ligne du bas ont le même rôle que dans le jeu originel : main gauche, 
buste du personnage, main droite et sac à doc.<br><br>

L'interaction entre le programe et le joueur s'effectue uniquement à l'aide de 
la souris. Lorsque le joueur clique sur une première carte, celle-ci devient 
"active" (ce qui sera symbolisé par un changement de couleur d'arrière-plan de 
la valeur numérique affiché au-dessous (pour la rangée du haut) ou en-dessous 
(pour la rangée du bas) de la carte sélectionnée. Puis en cliquant sur une 
seconde carte, une action sera réalisée entre les deux cartes, dont l'effet 
dépendra évidemment de la nature des cartes choisies (cf. la vidéo du jeu pour 
connaître toutes les actions possibles). Tant qu'il n'a pas cliqué sur la 
seconde carte, le joueur peut annuler son action en cours, en re-cliquant sur 
la carte active ; par contre, une fois la seconde carte cliquée, l'action ne 
pourra être annulée (il n'y a pas de fonction "undo" pour revenir dans 
l'historique du jeu, ce qui est une caractéristique commune de tous les jeux de 
type rogue-like).<br><br>

Comme pour tous les autres sujets de projet, l'implémentation devra mettre en 
oeuvre au moins deux classes : une classe noyau chargée de modéliser le jeu de 
manière abstraite, et une classe interface chargée de créer la fenêtre 
graphique pour visualiser le plateau de jeu et de gérer les actions du joueur.
Pour simplifier le développement du programme, on fournit une archive ZIP <a 
href="PROJET/crawl.zip"><b>crawl.zip</b></a> qui contient une grille d'images 
au format PNG <b>crawl.png</b> regroupant l'ensemble des images nécessaires à 
l'interface (dessins des cartes et des zones vides du plateau), ainsi qu'un 
fichier démo <b>crawlZ.py</b> qui pourra servir de point de départ pour 
l'implémentation. La décomposition en classes noyau/interface est déjà mise en 
oeuvre dans le fichier, mais comme pour le sujet précédent, il faudra compléter 
le code, en ajoutant des attributs et des méthodes dans chacune des classes. La 
mise en oeuvre des cartes magiques (telles qu'elles fonctionnent dans le jeu 
originel) est assez complexe et n'est donc pas demandé dans le cadre du projet. 
Néanmoins, si certains binômes souhaitent s'y attaquer, j'ai rajouté dans 
l'archive, une autre grille d'images <b>magic.png</b> regroupant 16 cartes 
magiques que vous pouvez insérer dans le mécanisme du jeu, sachant que vous 
êtes libre de définir vos propres règles pour l'utilisation et l'effet de ces 
cartes.<br><br>

<b>Exemples à relire avant de commencer le projet :</b><br>
<ol>
<li> Exercice E6A_slide.py (pour la gestion des clics dans un grille)
<li> Exemples D6_peg.py (pour la séparation noyau/interface d'un programme)
</ol>

<!---------------------------------------------------------------------------->
<h2>Projet 3 : Robozzle</h2>

Ecrire un programme <span class="prog">Robozzle</span> qui implémente un clone
du jeu <a href="http://www.robozzle.com/beta"><b>Robozzle</b></a> disponible
sur le site du même nom. Le jeu fait partie d'une grande famille de jeux de 
<b><i>programmation de robots</i></b>, dont le principe général est d'écrire un 
programme dans un langage simplifié pour déplacer un robot sur un plateau de 
jeu, et lui faire accomplir un certain nombre d'objectifs. Dans Robozzle, 
l'objectif est de programmer les mouvements du robot afin de récolter toutes 
les étoiles se trouvant sur une grille, sans sortir du chemin autorisé qui est
repéré par des cases de couleurs (rouge, vert, bleu) formant un graphe.<br><br>

La figure ci-dessous montre un exemple de problème à résoudre dans le jeu : il 
faut trouver les instructions de déplacement permettant au robot (flèche 
blanche) de se déplacer sur les cases bleues, tourner à gauche sur les cases 
vertes, tourner à droite sur la case rouge, pour finalement atteindre la case 
contenant l'étoile. Les mouvement du robot sont définis par une série d'icônes 
qui devront être correctement assemblées par le joueur pour remplir l'objectif 
demandé. Le rôle et la mise en oeuvre des différentes icônes sont expliqués en 
détail dans les tutoriels disponibles sur le site de Robozzle :<br><br>

<center><img src="../IMG/robozzle.png" width="768"></center><br>

Toutes les fonctionnalités concernant le langage de programmation et la gestion 
des différents niveaux à résoudre doivent être implémentées dans la classe 
noyau, et tout ce qui concerne l'affichage et la gestion des actions du joueur 
se place dans la classe interface. Pour simplifier l'implémentation, on fournit 
une archive ZIP <a href="PROJET/robozzle.zip"><b>robozzle.zip</b></a> qui 
contient une grille d'images au format PNG <b><i>robozzle.png</i></b> 
regroupant l'ensemble des icônes nécessaires à l'interface, ainsi qu'un fichier 
CSV <b><i>robozzle.csv</i></b> regroupant la description de 220 niveaux à 
résoudre, avec les solutions correspondants.<br><br>

<b>Exemples à relire avant de commencer le projet :</b><br>
<ol>
<li> Exercice E6A_slide.py (pour la gestion des clics dans un grille)
<li> Exemple E2C_toggle.py (pour l'animation des icônes dans une grille)
<li> Exemples D6_peg.py (pour la séparation noyau/interface d'un programme)
</ol>

<!---------------------------------------------------------------------------->
<h2>Projet 4 : OSCAR</h2>

Depuis leur développement il y a près de 30 ans, les systèmes multi-agents 
(SMA) ont été utilisés avec succès dans divers domaines. En éthologie, par 
exemple, les SMA servent comme outil de simulation pour étudier le comportement 
des insectes sociaux (fourmis, abeilles, etc). Dans ce contexte, les SMA 
consistent à définir un ensemble d'automates communicants qu'on laisse évoluer 
au cours du temps, afin de voir si l'on peut reproduire des comportements 
sociaux observés dans la nature. Le but du projet est de réaliser un petit 
simulateur appelé <span class="prog">oscar</span> (Outil de Simulation 
Comportemental par Attraction-Répulsion) consistant à animer des agents sur une 
grille, en fonction d'un modèle de comportement très simple basé sur un concept 
d'<b>attraction-répulsion</b>.<br><br>

Voici les principales caractéristiques du modèle utilisé :
<ul>
<li>La simulation se déroule sur une grille rectangulaire (appelée WORLD) sur 
laquelle vont évoluer des entités statiques ou dynamiques (appelés AGENT)</li>

<li>Chaque case de la grille ne peut contenir qu'un seul agent à un instant T 
de la simulation temporelle.</li>

<li>Chaque agent appartient à l'un des trois ordres suivants :
MINERAL, VEGETAL ou ANIMAL.</li>

<li>Un agent d'ordre MINERAL ne se déplace pas et ne se reproduit pas.</li>

<li>Un agent d'ordre VEGETAL ne se déplace pas mais peut se reproduire (sur une 
case adjacente à sa position courante).</li>

<li>Un agent d'ordre ANIMAL peut se déplacer et se reproduire (dans les deux 
cas, sur une case adjacente à sa position courante).</li>

<li>A chaque instant, un agent est dans un certain état (appelé STATUS) qui est 
identifié par l'utilisation d'une icône spécifique (ou simplement un rectangle 
de couleur spécifique) pour la visualisation de cet agent sur la grille.</li>

<li>Chaque agent est caractérisé par un ensemble de paramètres numériques 
(appelés VAR) dont les modifications entraînent un changement d'état lorsque 
les valeurs de ces paramètres franchissent des seuils prédéfinis. Le changement 
d'état d'un agent est visualisé par une modification de l'icône utilisée pour 
sa représentation sur la grille.</li>

<li>Un agent peut émettre autour de lui, un champ de potentiel (appelé FIELD) 
qui a une valeur maximale à la position courante de l'agent, et subit une 
décroissance isotrope (i.e. toutes les cases à une même distance de l'agent 
possèdent la même valeur de potentiel). Au-delà d'une certaine distance définie 
par la vitesse de décroissance, le potentiel émis par un agent devient 
nul.</li>

<li>Pour chaque case de la grille, et à chaque pas temporel, on va sommer tous 
les champs de potentiel qui portent le même nom, indépendamment de l'agent 
émetteur</li>

<li>Un agent peut capter un tel champ avec une acuité plus ou moins forte par
le biais d'un capteur (appelé SENSOR). Selon le signe du capteur, les champs
perçus peuvent être identifiés comme positifs, neutres ou négatifs.</li>

<li>Le déplacement et/ou la reproduction d'un agent s'effectue toujours
sur la case adjacente la plus favorable (i.e. la case où la somme obtenue en
ajoutant les champs perçus positivement et en retranchant les champs perçus
négativement, est maximale).</li>

<li>Lorsque deux agents se rencontrent (c'est-à-dire, qu'ils sont placés sur
deux cases adjacentes) chacun absorbe les champs émis par l'autre auxquels il
est sensible, ce qui va faire augmenter ou diminuer certains des paramètres
numériques caractérisant ces deux agents, et donc potentiellement entraîner un
changement d'état pour les deux agents. Par exemple, un agent ANIMAL herbivore
va absorber le paramètre "nutrition" d'un agent VEGETAL, ce qui va simultanément
faire augmenter le paramètre "nutrition" de l'agent ANIMAL et mettre à zéro,
ce même paramètre pour l'agent VEGETAL, ce qui devrait aboutir à sa suppression
de la grille, si un seuil critique est défini pour ce paramètre.</li>

<li>Afin de simplifier l'écriture des fichiers de configuration, on peut mettre 
en oeuvre un certain nombre d'états prédéfinis qui peuvent s'appliquer à tout 
type d'agent. Par exemple, l'état <b>void</b> identifie une case vide (et peut 
donc représenter la suppression d'un agent lors d'une transition), l'état 
<b>end</b> enclenche la fin du processus de simulation, l'état <b>trace</b> 
peut être utilisé pour identifier la case quittée lors d'un déplacement d'un 
agent de type ANIMAL, etc...</li>
</ul>

La description du terrain ainsi que des caractéristiques des agents utilisés 
pour une simulation particulière s'effectue par le biais d'un fichier texte, 
qui sera interprété par le programme avant de démarrer la simulation.
Ce fichier de structure très simple se compose d'une série de blocs 
(c'est-à-dire des groupes de lignes séparées par au moins une ligne vide), 
chacune définissant une des 5 commandes possibles: <b>world</b>, <b>mineral</b>,
<b>vegetal</b>, <b>animal</b> et <b>agent</b>. De plus, lorsqu'un caractère 
<b>#</b> apparait sur une ligne du fichier, les caractères à sa droite jusqu'à 
la fin de la ligne, sont considérés comme du commentaire.<br><br>

Mise à part la commande <b>world</b>, toutes les commandes peuvent apparaitre 
plusieurs fois, pour définir différents états ou différents agents. Dans la 
syntaxe ci-dessous, les termes en gras correspondent à des mots-clés et doivent 
donc apparaitre littéralement, alors que les autres termes correspondent à des 
paramètres et doivent être remplacés par une valeur numérique (pour les termes 
en italiques) ou alphanumérique (pour les termes en romanes). Le symbole 
<b>&lt;|&gt;</b> signifie que l'on peut mettre soit le signe inférieur soit le 
signe supérieur, afin de définir le sens de comparaison d'un paramètre par 
rapport à une valeur de seuil.<br><br>

<pre>
<b>world</b> <i>NumberRows</i> <i>NumberCols</i> VoidIcon_or_VoidColor

<b>mineral</b> StatusName StatusIcon_or_StatusColor
<b>var</b> VariableName <i>InitValue</i> <i>TimeStepValue</i>
<b>status</b> VariableName &lt;|&gt; <i>ThresholdValue</i> NewStatusName
<b>field</b> FieldName <i>DistanceStepValue</i>
<b>sensor</b> SensorName FieldName <i>SensitivityValue</i>

<b>vegetal</b> StatusName StatusIcon_or_StatusColor
<b>var</b> VariableName <i>InitValue</i> <i>TimeStepValue</i>
<b>status</b> VariableName &lt;|&gt; <i>ThresholdValue</i> NewStatusName
<b>birth</b> VariableName &lt;|&gt; <i>ThresholdValue</i> NewbornStatusName
<b>field</b> FieldName <i>DistanceStepValue</i>
<b>sensor</b> SensorName FieldName <i>SensitivityValue</i>

<b>animal</b> StatusName StatusIcon_or_StatusColor
<b>var</b> VariableName <i>InitValue</i> <i>TimeStepValue</i>
<b>status</b> VariableName &lt;|&gt; <i>ThresholdValue</i> NewStatusName
<b>birth</b> VariableName &lt;|&gt; <i>ThresholdValue</i> NewAgentStatusName
<b>trace</b> VariableName &lt;|&gt; <i>ThresholdValue</i> NewTraceStatusName
<b>field</b> FieldName <i>DistanceStepValue</i>
<b>sensor</b> SensorName FieldName <i>SensitivityValue</i>

<b>agent</b> StatusName <i>(row,col) (row,col) ...</i>
<b>agent</b> (StatusNameA,StatusNameB,...) <i>(rowA:rowB:step,colA:colB:step) ...</i>
</pre>

Pour mieux comprendre le rôle de ce fichier de configuration, voici quelques
exemples simples qui correspondent à des simulations classiques:<br>

<ul>
<li><a href="oscar1.txt">ForestFire = Propagation de feux de forêt</a>
<li><a href="oscar2.txt">WireWorld = Courant électrique</a>
<li><a href="oscar3.txt">LifeGame = Jeu de la Vie</a>
<li><a href="oscar4.txt">PhotoTropism = Croissance de plantes photophiles et photophobes</a>
<li><a href="oscar5.txt">Segregation = Modèle de ségrégation au sein d'une population</a>
<li><a href="oscar6.txt">Sugarscape = Recherche de nourriture par un animal</a>
</ul>
Les 3 premiers exemples n'utilisent que l'ordre "mineral" des agents, ce qui permet
de valider votre moteur sans avoir besoin de tout implémenter. Les autres exemples
utilisent également les ordres "vegetal" et "animal"</li>
<!---------------------------------------------------------------------------->
...
<address>Christophe Schlick </address>
</body></html>